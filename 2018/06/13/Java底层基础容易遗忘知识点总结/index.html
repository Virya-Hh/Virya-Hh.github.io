<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Virya-Hh" />



<meta name="description" content="jdk/jre的概念及相互之间的关系  jvm=java虚拟机  jre=jvm+核心类库 （jre是Java的运行环境）  jdk=jre+开发工具  （JdkJava 语言的软件开发工具包）  java语言诞生于1995年5月23日  ‘\n’指的的是回车，就是另起一行;’\r’指的的是换行，就是回到一行的开头 布尔值 boolean 当声明一个变量时，占用4个字节，当声明一个数组时，每个数">
<meta name="keywords" content="学习心得，Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java底层基础容易遗忘知识点总结">
<meta property="og:url" content="http://yoursite.com/2018/06/13/Java底层基础容易遗忘知识点总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="jdk/jre的概念及相互之间的关系  jvm=java虚拟机  jre=jvm+核心类库 （jre是Java的运行环境）  jdk=jre+开发工具  （JdkJava 语言的软件开发工具包）  java语言诞生于1995年5月23日  ‘\n’指的的是回车，就是另起一行;’\r’指的的是换行，就是回到一行的开头 布尔值 boolean 当声明一个变量时，占用4个字节，当声明一个数组时，每个数">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-16T03:08:52.017Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java底层基础容易遗忘知识点总结">
<meta name="twitter:description" content="jdk/jre的概念及相互之间的关系  jvm=java虚拟机  jre=jvm+核心类库 （jre是Java的运行环境）  jdk=jre+开发工具  （JdkJava 语言的软件开发工具包）  java语言诞生于1995年5月23日  ‘\n’指的的是回车，就是另起一行;’\r’指的的是换行，就是回到一行的开头 布尔值 boolean 当声明一个变量时，占用4个字节，当声明一个数组时，每个数">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Java底层基础容易遗忘知识点总结 | Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Virya-Hh</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/随笔">随笔</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gui/">gui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/华为题库/">华为题库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习心得/">学习心得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习心得，Java/">学习心得，Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Virya-Hh</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Virya-Hh</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/随笔">随笔</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Java底层基础容易遗忘知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/13/Java底层基础容易遗忘知识点总结/" class="article-date">
      <time datetime="2018-06-13T07:18:40.000Z" itemprop="datePublished">2018-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java底层基础容易遗忘知识点总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习心得，Java/">学习心得，Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>jdk/jre的概念及相互之间的关系</p>
<p> jvm=java虚拟机</p>
<p> jre=jvm+核心类库 （jre是Java的运行环境）</p>
<p> jdk=jre+开发工具  （JdkJava 语言的软件开发工具包）</p>
</li>
<li><p>java语言诞生于1995年5月23日</p>
</li>
<li>‘\n’指的的是回车，就是另起一行;’\r’指的的是换行，就是回到一行的开头</li>
<li>布尔值 boolean 当声明一个变量时，占用4个字节，当声明一个数组时，每个数组元素占用一个字节。</li>
<li>负数的存储原理：-7 先求-7的绝对值，然后求其二进制，取反+1 即为-7的补码。</li>
<li>% 正负号取决于被除数</li>
<li>编译器在编译的时候能确定常量的值，而不能确定变量的值，变量在运行时分配存储空间。但是+=在编译时可以进行强制类型转换，因此当用+=连接变量时，如果没有超过范围，是不会因为没有进行强制类型转换而报错的。</li>
<li>switch-case<br> 1）. switch 后边只可能跟 byte char int double short<br> 2）. 从上往下执行，若匹配上某case，执行cese中的代码，若没有遇break，则会不断的往下执行，直到遇到break<br> 3）. 无论顺序如何，永远先判断case, 没有符合的才执行default<a id="more"></a></li>
<li>堆内存和栈内存<ol>
<li>栈内存存储的是局部变量，一旦出了工作域就会从内存中消失，但是堆内存存储的是对象，不会立刻消失，只能等待垃圾回收器不定时的回收。任何new创建的对象jvm都会在堆内存中开辟一个空间</li>
</ol>
</li>
<li>反编译 javap -c -l -private  其中-c指的是输出字节码指令，-l指的是输出行及局部变量表 -private 指的是显示所有类和成员。</li>
<li>构造函数要注意的细节：<ol>
<li>构造函数是没有返回值类型的。</li>
<li>构造函数的函数名必须要与类名一致。</li>
<li>构造函数并不是由我们手动调用的，而是在创建对应的对象时，jvm就会主动调用到对应的构造函数。</li>
<li>如果一个类没有显式的写上一个构造方法时，那么java编译器会为该类添加一个无参的构造函数的。</li>
<li>如果一个类已经显式的写上一个构造方法时,那么java编译器则 不会再为该类添加 一个无参的构造方法。</li>
<li>构造函数是可以在一个类中以函数重载的形式存在多个的。</li>
</ol>
</li>
<li>代码块：在Java中，使用{}括起来的代码成为代码块<br>根据其位置和声明的不同，可以分为：<ol>
<li>局部代码块：局部位置，用于限定变量的生命周期 原因是：局部代码块的作用域是在代码块内，出了代码块之外变量就会释放。</li>
<li>构造代码块：在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。<br>作用：可以把多个构造方法的共同代码放在一起。 <ol start="3">
<li>静态代码块：在类中的成员位置，用{}括起来的代码，只不过它用static修饰<br>作用：一般是对类进行初始化 </li>
<li>静态代码块、构造代码块、构造方法的执行顺序？<br>静态-》构造代码块-》构造方法<br>静态代码块：只执行一次<br>构造方法：每次调用构造方法都执行 </li>
</ol>
</li>
</ol>
</li>
<li><p>this关键字</p>
<p>this关键字作用：</p>
<pre><code>1. 如果存在同名成员变量与局部变量时，在方法内部
2. 
3. 是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。
2. 在一个构造函数中可以调用另外一个构造函数初始化对象。
</code></pre></li>
</ol>
<pre><code>this关键字调用其他的构造函数要注意的事项：
    1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中的第一个语句。
    2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。

this关键字要注意事项：
    1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)
    2. 如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的前面添加this关键字。
</code></pre><ol start="14">
<li><p>单例设计模式的步骤：    </p>
<p>饿汉单例设计模式</p>
<ol>
<li>私有化构造函数。</li>
<li>声明本类的引用类型变量，并且使用该变量指向本类对象。</li>
<li>提供一个公共静态的方法获取本类的对象。</li>
</ol>
<p>懒汉单例设计模式：</p>
<ol>
<li>私有化构造函数。</li>
<li>声明本类的引用类型变量，但是不要创建对象，</li>
<li>提供公共静态 的方法获取本类 的对象，获取之前先判断是否已经创建了本类 对象，如果已经创建了，那么直接返回对象即可，如果还没有创建，那么先创建本类的对象，然后再返回。</li>
</ol>
</li>
</ol>
<pre><code>饿汉单例设计模式
1. 私有化构造函数。
2. 声明本类的引用类型变量，并且使用该变量指向本类对象。
3. 提供一个公共静态的方法获取本类的对象。

懒汉单例设计模式：
1. 私有化构造函数。
2. 声明本类的引用类型变量，但是不要创建对象，
3. 提供公共静态 的方法获取本类 的对象，获取之前先判断是否已经创建了本类 对象
，如果已经创建了，那么直接返回对象即可，如果还没有创建，那么先创建本类的对象，
然后再返回。

推荐使用： 饿汉单例设计模式。  因为懒汉单例设计模式会存在线程安全问题，目前还不能保证一类在内存中只有一个对象。
</code></pre><ol start="15">
<li><p>super关键字代表了父类空间的引用。</p>
<p>super关键字的作用：</p>
<pre><code>1. 子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以通过super关键字指定访问父类的成员。
2. 创建子类对象时，默认会先调用父类无参的构造方法，可以通过super关键字指定调用父类的构造方法。
</code></pre><p>super关键字调用父类构造方法要注意的事项：</p>
<pre><code>1. 如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在子类的构造方法上面加上super()语句。
2. super关键字调用父类的构造函数时，该语句必须要是子类构造函数中的第一个语句。
3. super与this关键字不能同时出现在同一个构造函数中调用其他的构造函数。因为两个语句都需要第一个语句。
</code></pre><p>super关键字与this关键字的区别：</p>
<pre><code>1. 代表的事物不一致。
    1. super关键字代表的是父类空间的引用。    
    2. this关键字代表的是所属函数的调用者对象。
2. 使用前提不一致。
    1. super关键字必须要有继承关系才能使用。
    2. this关键字不需要存在继承关系也可使用。
3. 调用构造函数的区别：
    1. super关键字是调用父类的构造函数。
    2. this关键字是调用本类的构造函数。
</code></pre></li>
<li><p>方法重写的前提： 必须要存在继承的关系。</p>
<p><strong>方法的重写</strong>: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>
<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>
<p>方法重写要注意的事项：</p>
<pre><code>1.方法重写时， 方法名与形参列表必须一致。
2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。
3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。
4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。
        Exception(最坏)
        RuntimeException(小坏)
</code></pre><p><strong>方法的重载</strong>：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>
<p>方法重载的要求：</p>
<pre><code>1. 函数名要一致。
2. 形参列表不一致（形参的个数或形参 的类型不一致）
3. 与返回值类型无关。
</code></pre></li>
<li>抽象类的好处: 强制要求子类一定要实现指定的方法。</li>
</ol>
<pre><code>抽象类要注意的细节：

        1. 如果一个函数没有方法体，那么该函数必须要使用abstract修饰,把该函数修饰成抽象 的函数。。
        2. 如果一个类出现了抽象的函数，那么该类也必须 使用abstract修饰。
        3. 如果一个非抽象类继承了抽象类，那么必须要把抽象类的所有抽象方法全部实现。
        4. 抽象类可以存在非抽象方法，也可以存在抽象的方法.
        5. 抽象类可以不存在抽象方法的。 
        5. 抽象类是不能创建对象的。
            疑问：为什么抽象类不能创建对象呢？
            因为抽象类是存在抽象方法的，如果能让抽象类创建对象的话，那么使用抽象的对象
            调用抽象方法是没有任何意义的。
        6. 抽象类是存在构造函数的，其构造函数是提供给子类创建对象的时候初始化父类的属性的。
</code></pre><ol start="18">
<li>值传递: 调用一个方法的时候，传递给方法的参数 ，实际上传递变量所存储的值。</li>
</ol>
<pre><code>import java.util.*;
class Person{

    int x =10;
}


class Demo5 
{
    public static void main(String[] args) 
    {
        /*
        int a = 3;
        int b = 5; 
        changeValue(a,b);
        System.out.println(&quot;交换之后的值：a = &quot;+a +&quot; b=&quot;+b); 

        int[] arr = {23,10,9};
        changeArr(arr,1,2);
        System.out.println(&quot;数的元素：&quot;+ Arrays.toString(arr));// 9 ,10
            */
        Person p = new Person();
        changeObj(p,20);
        System.out.println(&quot;x = &quot;+ p.x);
    }

    public static void changeObj(Person p ,int x){
        p.x = x;
    }




    //需求2： 定义一个函数交换数组中两个 元素的位置。
    public  static void changeArr(int[] arr , int index1,  int  index2){
        int temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;

    }



    //需求1：定义一个函数交换两个基本类型变量的值。 
    public static void changeValue(int a , int b){
        int temp = a;
        a = b;
        b = temp;
        System.out.println(&quot;方法内部交换的值：a = &quot;+a +&quot; b=&quot;+b);
    }

}
</code></pre><p><strong>自我总结：</strong> 只要传入交换函数的变量值是地址时，就可以实现交换。是因为传入的是地址时，虽然传入的变量和原来的变量不是一个，但是指向了同一个地址，因此对于交换值是有效的，例如上个例子中传入的arr,是数组的地址，在栈内存中，指向堆内存中的数组，还有对象p,也是指的的地址。</p>
<ol start="17">
<li><p>接口的定义格式：</p>
<p>interface 接口名{</p>
<p>}</p>
<p>接口要注意的事项 ：</p>
<pre><code>1. 接口是一个特殊的类。
2. 接口的成员变量默认的修饰符为： public static final 。那么也就是说接口中的成员变量都是常量。
3. 接口中的方法都是抽象的方法，默认的修饰符为： public abstract。
4. 接口不能创建对象。
5. 接口是没有构造方法的。
6. 接口是给类去实现使用的，非抽象类实现一个接口的时候，必须要把接口中所有方法全部实现。
</code></pre><p>接口的作用：</p>
<ol>
<li>程序的解耦。  （低耦合）</li>
<li>定义约束规范。</li>
<li>拓展功能。</li>
</ol>
</li>
<li><p>类与接口之间关系： 实现关系。</p>
<p>类与接口要注意的事项：</p>
<pre><code>1. 非抽象类实现一个接口时，必须要把接口中所有方法全部实现。
2. 抽象类实现一个接口时，可以实现也可以不实现接口中的 方法。
3. 一个类可以实现多个接口 。
</code></pre></li>
</ol>
<p><strong>自我总结：</strong> 单继承与多实现的原因：单继承是因为当有两个父类拥有同函数名的函数时，自类无法辨认继承哪个函数。多实现时候，当出现上述情况，自类自己去实现函数的实体，因此不会有冲突。</p>
<ol start="19">
<li>多态：一个对象具备多种形态。(父类的引用类型变量指向了子类的对象)</li>
</ol>
<p>或者是接口 的引用类型变量指向了接口实现类的对象)</p>
<p>多态的前提：必须存在继承或者实现 关系。</p>
<pre><code>动物  a  = new   狗();
</code></pre><p>多态要注意的细节：</p>
<pre><code>1.  多态情况下，子父类存在同名的成员变量时，访问的是父类的成员变量。
2.  多态情况下，子父类存在同名的非静态的成员函数时，访问的是子类的成员函数。
3.  多态情况下，子父类存在同名的静态的成员函数时，访问的是父类的成员函数。
4.  多态情况下，不能访问子类特有的成员。

总结：多态情况下，子父类存在同名的成员时，访问的都是父类的成员，除了在同名非静态函数时才是访问子类的。
</code></pre><ol start="20">
<li><p>编译看左边，运行不一定看右边。</p>
<p>编译看左边：java编译器在编译的时候，会检查引用类型变量所属的类是否具备指定的成员，如果不具备马上编译报错。</p>
</li>
<li><p>抽象类：</p>
<p>什么是时候使用抽象类：</p>
<pre><code>描述一类事物的时候，发现该事物确实存在着某种行为，但是 目前这种是不具体的，这时候应该抽取这种行为的声明，而不去实现该种行为，这时候这种行为我们把它称为抽象的行为，这时候应该使用抽象类。
</code></pre><p>抽象类要注意的细节：</p>
<pre><code>1. 如果一个方法没有方法体，那么该方法必须使用abstract修饰。
2. 如果一个类函数抽象方法，那么这个类肯定是一个抽象类或者接口。
3. 抽象类不能创建对象。
4. 抽象类是含有构造方法的。
5. 抽象类可以存在非抽象方法与抽象方法。
6. 抽象类可以不存在抽象方法。
7. 非抽象类继承抽象类的时候，必须要把抽象类中所有抽象方法全部实现。
</code></pre><p>abstract不能与以下关键字一起使用</p>
<pre><code>1. abstract 不能与static共同修饰一个方法。
2. abstract 不能与private共同修饰一个方法。
3. abstract不能以final关键字共同修饰一个方法。
</code></pre><p>原因：1.  因为static修饰的方法是静态方法，其可以直接被类所调用。而abstract修饰的方法为抽象方法，即无方法体的方法，不能够被直接调用，需要在子类或实现类中去编写完整的方法处理逻辑后才能使用。2. private修饰的类只可以定义在内部类；private 修饰的方法/属性只可以在类中调用，重写时是访问不到这些方法和属性的。3. final 修饰的类/方法/属性均不可再次更改，故而不可以被重写。</p>
</li>
<li><p>匿名内部类：没有类名的类就称作为匿名内部类。</p>
<p>匿名内部类的好处：简化书写。</p>
<p>匿名内部类的使用前提：必须存在继承或者实现关系才能使用。</p>
</li>
</ol>
<pre><code>匿名内部类一般是用于实参。
</code></pre><ol start="21">
<li>匿名内部类：<br>匿名内部类在调用自己特有的方法时，只能用<br>new Animal(){}.bite(); bite指的是函数名称或者直接用局部内部类进行调用，不能使用Animal a=new Animal(){}; a.bite();是因为多多态的影响，需要进行强转，但是匿名内部类无法进行强转。<br>匿名内部类时，new Animal(){};即指的的是对象。</li>
<li><p>异常的处理：</p>
<p> 方式一：捕获处理</p>
<p>  捕获处理的格式：</p>
<pre><code>try{
    可能发生异常的代码；

}catch(捕获的异常类型 变量名){
    处理异常的代码....
}
</code></pre></li>
</ol>
<pre><code>    捕获处理要注意的细节：
        1. 如果try块中代码出了异常经过了处理之后，那么try-catch块外面的代码可以正常执行。
        2. 如果try块中出了异常的代码，那么在try块中出现异常代码后面的代码是不会执行了。
        3. 一个try块后面是可以跟有多个catch块的，也就是一个try块可以捕获多种异常的类型。
        4. 一个try块可以捕获多种异常的类型,但是捕获的异常类型必须从小到大进行捕获，否则编译报错。


疑问一 : 异常的处理感觉没有多大作用，因为都是输出一个话而已?
        异常处理非常有用，只不过是由于我们目前所接触的知识点太过于局限而已。

疑问二： 以后捕获处理 的时候是否就是捕获Exception即可？
    错的，因为我们在现实开发中遇到不同的异常类型的时候，我往往会有不同 的处理方式。
    所以要分开不同的异常类型处理。

方式二：抛出处理

抛出处理（throw throws）


抛出处理要注意的细节：
        1. 如果一个方法的内部抛出了一个异常 对象，那么必须要在方法上声明抛出。
        2. 如果调用了一个声明抛出异常 的方法，那么调用者必须要处理异常。
        3. 如果一个方法内部抛出了一个异常对象，那么throw语句后面的代码都不会再执行了（一个方法遇到了throw关键字，该方法也会马上停止执行的）。
        4. 在一种情况下，只能抛出一种类型异常对象。

throw 与throws两个关键字：
    1. throw关键字是用于方法内部的，throws是用于方法声声明上的。
    2. throw关键字是用于方法内部抛出一个异常对象的，throws关键字是用于在方法声明上声明抛出异常类型的。
    3. throw关键字后面只能有一个异常对象，throws后面一次可以声明抛出多种类型的 异常。


疑问：何时使用抛出处理？何时捕获处理？原则是如何？
    如果你需要通知到调用者，你代码出了问题，那么这时候就使用抛出处理.
    如果代码是直接与用户打交道遇到了异常千万不要再抛，再抛的话，就给了用户了。
    这时候就应该使用捕获处理。
</code></pre><ol start="23">
<li>内部类</li>
</ol>
<p>内部类类别：</p>
<pre><code>成员内部类: 在一个类的成员位置定义另外一个类，那么另外 一个 类就称作为成员内部类。

    成员内部类的访问方式：
        方式1： 在外部类内提供一个方法创建内部类的对象进行访问。

        方式2： 在其他类创建内部类的对象进行访问。 创建的格式： 外部类.内部类  变量名 = new 外部类().new 内部类();

        注意：如果是静态内部类在其他类的创建对象方式：  外部类.内部类 变量名=  new 外部类.内部类();

    成员内部类要注意的事项：
        1. 成员内部类可以直接访问外部类成员。
        2. 如果成员内部类与外部类存在同名的成员，在内部类中默认是访问内部类 的成员。
            成员通过“外部类.this.成员”指定访问外部类的成员。
        3. 如果成员内部类出现了静态的成员，那么该成员内部类也必须使用static修饰。
        4. 如果成员内部类是私有的，那么创建内部类的对象就只能在外部类提供方法创建。

局部内部类  ： 在一个类的方法内部定义另外一个类,  另外一个类就称作为局部内部类。

局部内部类要注意： 如果局部内部类访问了局部变量，那么该变量需要使用fianl修饰。 （原因： 因为生命周期不一致，所以内部类访问局部变量其实是一个复制品。）


匿名内部类 : 没有类名的类。

匿名内部类的好处： 简化书写。

匿名内部类的使用前提： 必须存在继承或者实现关系。

匿名内部类的格式：

    new 父类(父接口){

        匿名内部类的成员;

    };
</code></pre><ol start="24">
<li><p>权限修饰符： 权限修饰符就是控制被修饰的成员的范围可见性。</p>
<pre><code>            public(公共)        protected(受保护)           default(缺省)       private (大到小)

同一个类      true                 true                        true                 true
</code></pre></li>
</ol>
<pre><code>同一个包      true                 true                        true                  false


子父类        true                  true                      false                   false


不同包        true                 false                      false                   false
</code></pre><p>注意： 在不同包下面只有public 与 protected 可以访问，而且protected必须是在继承关系下才能够访问</p>
<ol start="25">
<li>模板模式 ：解决某类事情的步骤有些是固定的，有些是会发生变化的，那么这时候我们可以<br>为这类事情提供一个模板代码，从而提高效率 。</li>
</ol>
<pre><code>需求；编写一个计算程序运行时间的模板。

模板模式的步骤：
    1. 先写出解决该类事情其中的一件的解决方案。
    2. 分析代码，把会发生变化的代码抽取出来独立成一个方法。把该方法描述成一个抽象的方法。
    3. 使用**final**修饰模板方法，防止别人 
    4. 
    5. 你的模板方法。
</code></pre><ol start="26">
<li>如果一个函数传入的是一个接口类型，实际上传入的是该接口的实现类对象。</li>
<li>如果需要将一个文件导入eclipse中时，File–&gt;Import–&gt;General–&gt;Existing Projects into Workspace—-&gt;Next—&gt;select root directory 选择一个路径—&gt;finish即可。<ol start="28">
<li>bject类：</li>
</ol>
</li>
</ol>
<pre><code>Object类常用的方法：
    toString();     返回该对象的字符串表示。 返回一个字符串用于描述该对象的。返回的字符标识：完整类名+@+对象哈希吗
疑问： toString() 有何作用？      重写toString之后，我们直接输出一个对象的时候，就会输出符合我们所需求的格式数据。

    equals(Object obj)   用于比较两个对象的内存地址，判断两个对象是否为同一个对象。

    hashCode()   返回该对象的哈希码值(大家可以把哈希码就 理解成是对象的内存地址)/
</code></pre><p><strong><br>    java中的规范</strong>：一般我们重写了一个类的equals方法，我们都会重写它的hashCode方法。但是如果是重写了一个类的hashcode方法的时候，不需要重写equals方法。</p>
<p><strong>注意：</strong></p>
<pre><code>1. String类重写了Object的equals方法，比较的是两个字符串对象 的内容 是否一致。
2. &quot;==&quot;用于比较 引用数据类型数据的时候比较的是两个对象 的内存地址，equals方法默认情况下比较也是两个对象 的内存地址。
</code></pre><ol start="29">
<li>自定义线程的创建方式:</li>
</ol>
<p>方式一 ： </p>
<pre><code>1. 自定义一个类继承Thread类。
2. 重写Thread类的run方法，把自定义线程的任务代码写在run方法上。
3. 创建Thread的子类对象，并且调用start方法启动一个线程。 

注意：千万不要直接调用run方法，调用start方法的时候线程就会开启，线程一旦开启就会执行run方法中代码，如果直接调用
run方法，那么就 相当于调用了一个普通的方法而已。
</code></pre><p>方式二：</p>
<pre><code>1. 自定义一个类实现Runnable接口。
2. 实现Runnable接口 的run方法，把自定义线程的任务定义在run方法上。
3. 创建Runnable实现类对象。
4. 创建Thread类 的对象，并且把Runnable实现类的对象作为实参传递。
5. 调用Thread对象 的start方法开启一个线程。
</code></pre><p>问题1： 请问Runnable实现类的对象是线程对象吗？<br>    Runnable实现类的对象并 不是一个线程对象，只不过是实现了Runnable接口 的对象而已。<br>    只有是Thread或者是Thread的子类才是线程 对象。</p>
<p>问题2： 为什么要把Runnable实现类的对象作为实参传递给Thread对象呢？作用是什么？<br>    作用就是把Runnable实现类的对象的run方法作为了线程的任务代码去执行了。</p>
<p>推荐使用： 第二种。 实现Runable接口的。<br>原因： 因为java单继承 ,多实现的。</p>
<ol start="30">
<li>线程通讯： 一个线程完成了自己的任务时，要通知另外一个线程去完成另外一个任务.</li>
</ol>
<p>生产者与消费者</p>
<pre><code>wait():  等待   如果线程执行了wait方法，那么该线程会进入等待的状态，等待状态下的线程必须要被其他线程调用notify方法才能唤醒。
notify()： 唤醒    唤醒线程池等待线程其中的一个。
notifyAll() : 唤醒线程池所有等待 线程。


wait与notify方法要注意的事项：
    1. wait方法与notify方法是属于Object对象 的。
    2. **wait方法与notify方法必须要在同步代码块或者是同步函数中才能使用。**
    3. wait方法与notify方法必需要由锁对象调用。
</code></pre><ol start="31">
<li>进程: 进程就是正在运行的应用程序。 进程了负责了内存空间划分。</li>
</ol>
<p>线程： 一个进程中的 代码是由线程去执行的，线程也就是进程中一个执行路径。</p>
<p>多线程： 一个进程中有多个线程可以同时执行任务。</p>
<p>多线程 的好处：</p>
<pre><code>1. 解决一个进程中可以同时执行多个任务的问题。
2. 提高了资源利用率。
</code></pre><p>多线程的弊端：</p>
<pre><code>1. 增加了cpu的负担。
2. 降低了一个进程中线程 的执行概率。
3. 出现了线程 安全问题。
4. 会引发死锁现象。
</code></pre><p>自定义线程 的实现方式：</p>
<pre><code>方式一 ： 
    1. 自定义一个类继承Thread类。
    2. 重写Thread类的run方法，把自定义线程的任务代码写在run方法上。
    3. 创建Thread的子类对象，并且调用start方法启动一个线程。 

注意：千万不要直接调用run方法，调用start方法的时候线程就会开启，线程一旦开启就会执行run方法中代码，如果直接调用
run方法，那么就 相当于调用了一个普通的方法而已。
</code></pre><p>线程安全问题：</p>
<p>线程安全出现 的根本原因：</p>
<pre><code>1. 存在两个或者两个以上的线程对象共享同一个资源。
2. 多线程操作共享资源的代码 有多句。
</code></pre><p>线程安全问题的解决方案：</p>
<pre><code>方式一： 可以使用同步代码块去解决。

格式：
    synchronized(锁对象){
        需要被同步的代码
    }
</code></pre><p>同步代码块要注意的事项：</p>
<pre><code>1. 锁对象可以是任意的一个对象。
2. 一个线程在同步代码块中sleep了，并不会释放锁对象。
3. 如果不存在着线程安全问题，千万不要使用同步代码块，因为会降低效率。
4. 锁对象必须是多线程共享的一个资源，否则锁不住。


方式二：同步函数  ：  同步函数就是使用synchronized修饰一个函数。

同步函数要注意的事项 ：
    1. 如果是一个非静态的同步函数的锁 对象是this对象，如果是静态的同步函数的锁 对象是当前函数所属的类的字节码文件（class对象）。
    2. 同步函数的锁对象是固定的，不能由你来指定 的。


推荐使用： 同步代码块。
    原因：
        1. 同步代码块的锁对象可以由我们随意指定，方便控制。同步函数的锁对象是固定 的，不能由我们来指定。
        2. 同步代码块可以很方便控制需要被同步代码的范围，同步函数必须是整个函数 的所有代码都被同步了。
</code></pre><ol start="32">
<li>集合：集合是存储对象数据的集合容器。&lt;接口&gt;</li>
</ol>
<p>集合比数组的优势：</p>
<pre><code>1. 集合可以存储任意类型的对象数据，数组只能存储同一种数据类型 的数据。
2. 集合的长度是会发生变化的，数组的长度是固定的。
</code></pre><p>——-| Collection  单例集合的跟接口。<br> ———-| List  如果是实现了List接口的集合类，具备的特点： 有序，可重复。<br> ———-| Set   如果是实现了Set接口的集合类，具备特点： 无序，不可重复。</p>
<p>Collection接口中的方法：</p>
<pre><code>增加
    add(E e)  返回布尔值，添加成功返回true，失败返回false.
    addAll(Collection c)  把一个集合 的元素添加到另外一个集合中去。

删除
    clear() 
    remove(Object o) （若o是重复元素，只删除第一个）

    removeAll(Collection  c) （删除调用者中与另一集合的交集元素）
    retainAll(Collection  c) 保留调用者中与另一集合的交集元素）

查看
    size() 


判断
    isEmpty() 
    contains(Object o) 其实contains方法内部是依赖于equals方法进行比较的。
    containsAll(Collection&lt;?&gt; c) 

迭代
    toArray() 
    iterator()     
</code></pre><p>个人总结：在String类中，重写了equals方法，因此是比较两个字符串的内容        </p>
<ol start="33">
<li><p>使用ArrayList无参的构造，函数创建一个对象时，默认的容量是多少？如果长度不够使用时又自增增长多少？<br>ArrayList底层是维护了一个Object数组实现的，使用无参构造函数时，Object数组默认的容量是10，当长度不够的时候，自动增长0.5倍。</p>
</li>
<li><p>说出ArrayLsit与Vector的区别?<br>相同点： ArrayList与Vector底层都是使用了Object数组实现的。</p>
<p>不同点： </p>
<pre><code>1. ArrayList是线程不同步的，操作效率高。 
   Vector是线程同步的，操作效率低。
2. ArrayList是JDK1.2出现，Vector是jdk1.0的时候出现的。
</code></pre></li>
<li><p>hashSet的实现原理：<br>往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，<br>然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。</p>
<p>情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</p>
<p>情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次<br>，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行 添加。</p>
</li>
<li><p>HashCode默认情况下表示的是内存地址，String 类已经重写了Object的hashCode方法了。</p>
<p>注意： 如果两个字符串的内容一致，那么返回的hashCode 码肯定也会一致的。 </p>
</li>
<li><p>treeSet要注意的事项：</p>
<ol>
<li>往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。</li>
<li><p>往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素<br>的比较规则定义在compareTo(T o)方法上。 </p>
</li>
<li><p>如果比较元素的时候，compareTo方法返回 的是0，那么该元素就被视为重复元素，不允许添加.(注意：TreeSet与HashCode、equals方法是没有任何关系。)</p>
</li>
<li><p>往TreeSet添加元素的时候, 如果元素本身没有具备自然顺序 的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个<br>比较器。</p>
</li>
<li><p>往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口， 在创建TreeSet对象的时候也传入了比较器<br>那么是以比较器的比较规则优先使用。</p>
</li>
</ol>
</li>
</ol>
<pre><code>如何自定义定义比较器： 自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法内即可。

    自定义比较器的格式 ：

        class  类名  implements Comparator{

        }

推荐使用：使用比较器(Comparator)。 
</code></pre><ol start="38">
<li>泛型是jdk1.5使用的新特性。</li>
</ol>
<p>  泛型的好处：</p>
<pre><code>1. 将运行时的异常提前至了编译时。
2. 避免了无谓的强制类型转换 。
</code></pre><p>泛型在集合中的常见应用：</p>
<pre><code>ArrayList&lt;String&gt;  list = new ArrayList&lt;String&gt;();  true     推荐使用。

ArrayList&lt;Object&gt;  list = new ArrayList&lt;String&gt;();  false
ArrayList&lt;String&gt;  list = new ArrayList&lt;Object&gt;();  false
</code></pre><p>//以下两种写法主要是为了兼顾新老系统的兼用性问题。</p>
<pre><code>   * 
ArrayList&lt;String&gt;  list = new ArrayList();           true   

ArrayList    list = new ArrayList&lt;String&gt;();   true   
</code></pre><p>注意： 泛型没有多态的概念，左右两边的数据 类型必须 要一致，或者只是写一边的泛型类型。</p>
<p>推荐使用： 两边都写泛型。</p>
<p>需求： 定义一个方法可以接收任意类型的参数，而且返回值类型必须 要与实参的类型一致。</p>
<ol start="39">
<li><p>自定义泛型：  自定义泛型就是一个数据类型的占位符或者是一个数据类型的变量。</p>
<p> 方法上自定义泛型：</p>
<pre><code>修饰符      &lt;声明自定义的泛型&gt;返回值类型    函数名(使用自定义泛型 ...){

}
</code></pre></li>
</ol>
<pre><code>在泛型中不能使用基本数据类型，如果需要使用基本数据类型，那么就使用基本数据类型对应的包装类型。

 byte----&gt; Byte
 short---&gt; Short 
 int----&gt; Integer
 long----&gt; Long 

 double ----&gt; Double 
 float -----&gt; Float

 boolean-----Boolean

 char-------》 Character 


 方法泛型注意的事项：
     1. 在方法上自定义泛型，这个自定义泛型的具体数据类型是在调用该 方法的时候传入实参时确定具体的数据类型的。
     2. 自定义泛型只要符合标识符 的命名规则即可, 但是自定义泛型我们一般都习惯使用一个大写字母表示。  T Type  E Element
</code></pre><ol start="40">
<li><p>单例集合 的体系：<br>———| Collection 单例集合的根接口<br>————| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。<br>—————| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。<br>—————| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。<br>—————| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的<br>————| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。<br>—————-| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。<br>HashSet添加元素的原理：<br>往HashSet添加元素的时候，首先HashSet会调用元素的hashCOde方法得到元素的哈希码值，然后会经过一系列运算<br>就可以算出该元素在哈希表中的存储位置/</p>
<p>情况1：如果算出该元素的位置目前没有任何元素存储，那么该元素可以直接存储　</p>
<p>情况2： 如果算出该元素的位置目前已经存有其他的元素，那么还会调用元素的equals方法与该位置的元素再比较一次。<br>如果equals方法返回的是false，那么该元素允许存储，如果euqlas方法返回的是true，那么该元素被视为重复元素，不允许存储。<br>——————| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。</p>
</li>
</ol>
<p>TreeSet要注意的事项：</p>
<pre><code>1. 往TreeSet添加元素的时候，如果元素本身具备自然顺序的特性，那么会根据元素自然顺序的特性进行排序存储。
2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么元素所属的类必须要实现Comparable接口，把元素的比较规则定义
在CompareTo方法上。
3. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而且元素所属的类没有实现COmparable接口，那么必须要在创建
TreeSet对象的时候传入比较器。
4. 如果比较的方法(CompareTo 或者Compare )返回的是0的时候，那么该元素就被视为重复元素，不允许添加。

比较器的定义格式：  自定义一个类实现COmparator接口即可。

    class 类名  implements Comparator{

    }
</code></pre><p>泛型：泛型是jdk1.5出现的新特性。</p>
<p>泛型的好处：</p>
<pre><code>1. 将运行时出现 的问题提前至了编译时。
2. 避免了无谓强制类型转换。
</code></pre><p>自定义泛型： 自定义泛型就是一个数据类型的占位符或者理解为一个数据类型的变量。    </p>
<p>泛型方法:</p>
<pre><code>修饰符  &lt;声明自定义的泛型&gt;返回值类型  函数名(自定义的泛型  变量名..)
</code></pre><p>泛型方法要注意的事项： </p>
<pre><code>1. 泛型方法中 的自定义泛型的具体数据类型是在调用该函数的时候传入实参时确定的。
2. 自定义泛型所用 的标识符只要符合标识符 的命名规则即可。但是我们一般都习惯使用一个大写字母表示。
</code></pre><p>泛型类：</p>
<pre><code>泛型类的定义格式

    class 类名&lt;声明自定义的泛型&gt;{

    }
</code></pre><p>泛型类要注意的事项：</p>
<pre><code>1. 泛型类上的自定义泛型是在使用该类创建对象的时候指定具体的数据类型的。
2. 如果一个类已经自定义了泛型，使用该类创建对象的时候如果没有指定泛型的具体数据类型，那么默认为Object类型。
3. 静态的函数不能使用类上自定义的泛型，如果静态函数需要使用，必须要在函数上自定义泛型。
</code></pre><p>泛型接口：</p>
<pre><code>泛型接口的定义格式：

    interface 接口名&lt;声明自定义的泛型&gt;{

    }
</code></pre><p>泛型接口要注意事项：</p>
<pre><code>1. 泛型接口上的自定义泛型是在实现该接口的时候指定具体数据类型的。
2. 如果实现接口的时候没有指定接口上 的自定义泛型的具体数据类型，那么默认为Object数据类型。
3. 如果需要在创建接口实现类对象的时候才指定接口上自定义泛型，那么需要以下格式：    class&lt;T&gt; 类名  implements  接口&lt;T&gt;
</code></pre><p>泛型上下限：</p>
<pre><code>? super Integer   允许是Integer数据类型或者是Integer父类类型       泛型的下限


?  extedns Number  允许是Number数据类型或者是Number子类的数据类型   泛型的上限。
</code></pre><ol start="41">
<li><p>mkdir和 creatNewFile的区别<br>mkdir指的是创建一个文件夹<br>而creatNewFile指的是创建一个文件<br>mkdirs指的是可以创建多级文件夹<br>dir指的是directory 因此指的是文件夹</p>
</li>
<li><p>jdk1.5新特性之——-静态导入</p>
<p> 静态导入的作用： 简化书写。</p>
<p>静态导入可以作用一个类的所有静态成员。 </p>
<p> 静态导入的格式：</p>
<pre><code>import static 包名.类名.静态的成员；
</code></pre></li>
</ol>
<pre><code>静态导入要注意的事项： 
     1. 如果静态导入的成员与本类的成员存在同名的情况下，那么默认使用本类的静态成员，如果需要指定使用静态导入的成员，那么需要在静态成员前面加上类名
</code></pre><ol start="43">
<li><p>jdk1.5出现的新特性—-&gt;增强for循环</p>
<p>增强for循环的作用： 简化迭代器的书写格式。(注意：增强for循环的底层还是使用了迭代器遍历。)</p>
<p>增强for循环的适用范围： 如果是实现了Iterable接口的对象或者是数组对象都可以使用增强for循环。</p>
<p>set 已经实现了iterable接口。。。</p>
<p>增强for循环的格式：</p>
<pre><code>for(数据类型  变量名  :遍历的目标){

}
</code></pre><p>增强for循环要注意的事项：</p>
<pre><code>1. 增强for循环底层也是使用了迭代器获取的，只不过获取迭代器由jvm完成，不需要我们获取迭代器而已，所以在使用增强for循环变量元素的过程中不准使用集合
对象对集合的元素个数进行修改。

2. 迭代器遍历元素与增强for循环变量元素的区别：使用迭代器遍历集合的元素时可以删除集合的元素，而增强for循环变量集合的元素时，不能调用迭代器的remove方法删除元素。

3. 普通for循环与增强for循环的区别：普通for循环可以没有变量的目标，而增强for循环一定要有变量的目标。
</code></pre><p>map没有实现iterable接口，但是可以把map转化为单例集合set&lt;Map.entry&lt;String,String&gt;&gt;</p>
<ol start="44">
<li><p>jdk1.5新特性之——-&gt;可变参数</p>
<p>需求： 定义一个函数做加法功能（函数做几个数据 的加法功能是不确定）。</p>
<p>可变参数的格式：</p>
<pre><code>数据类型... 变量名
</code></pre><p>可变参数要 注意的细节： </p>
<pre><code>1. 如果一个函数 的形参使用上了可变参数之后，那么调用该方法的时候可以传递参数也可以不传递参数。
2. 可变参数实际上是一个数组对象。
3. 可变参数必须位于形参中的最后一个参数。
4. 一个函数最多只能有一个可变 参数，因为可变参数要位于形参中最后一个位置上。
</code></pre></li>
<li><p>jdk1.5新特性之—–枚举</p>
<p>问题：某些方法所接收的数据必须是在固定范围之内的， </p>
</li>
</ol>
<p>解决方案： 这时候我们的解决方案就是自定义一个类,然后是私有化构造函数，在自定义类中创建本类的对象对外使用。</p>
<p>jdk1.5对以上问题提出了新的解决方案： 就是使用枚举类解决。</p>
<p>一些方法在运行时，它需要的数据不能是任意的，而必须是一定范围内的值，Java5以后可以直接使用枚举予以解决。</p>
<pre><code>比如： 方向 , 性别 、 季节 、 星期......
</code></pre><ol start="44">
<li>自动装箱与拆箱</li>
</ol>
<p>//集合： 集合是可以存储任意对象类型数据的容器。</p>
<pre><code>ArrayList list = new ArrayList();
list.add(1);
list.add(2);
list.add(3);

//自动装箱： 自动把java的基本数据类型数据转换成对象类型数据。
int temp = 10;  //基本数据类型
Integer b =temp; //把a存储的值赋予给b变量。
</code></pre></li>
</ol>
<pre><code>    //自动拆箱： 把引用类型的数据转换成基本类型的数据
    Integer c = new Integer(13);
    int d = c; //
    System.out.println(d);

45. 枚举：一些方法在运行时，它需要的数据不能是任意的，而必须是一定范围内的值，可以直接使用枚举予以解决。


枚举类的定义格式：

    enum 类名{
        //枚举值
    }

枚举要注意的细节：
    1. 枚举类也是一个特殊的类。
    2. 枚举值默认的修饰符是public static final。
    3. 枚举值就是是枚举值所属的类的类型， 然后枚举值是指向了本类的对象的。
    4. 枚举类的构造方法默认的修饰符是private的。
    5. 枚举类可以定义自己的成员变量与成员函数。
    6. 枚举类可以自定义构造函数，但是构造函数的修饰符必须是private。
    7. 枚举类可以存在抽象 的方法，但是枚举值必须要实现抽象 的方法。
    8. 枚举值必须要位置枚举类 的第一个语句。    
</code></pre><ol start="45">
<li><p>switch适用的数据类型： byte \ char \short \ int \ String\枚举类型</p>
<p> 注意： </p>
<p> case语句后面跟的枚举值，只需要单写枚举值即可，不需要再声明该 枚举值是属于哪个枚举类的。</p>
</li>
<li><p><a href="https://blog.csdn.net/lwang_it/article/details/78886186" target="_blank" rel="noopener">java 字节流与字符流的区别</a></p>
<p>字节流: 字节流读取得都是文件中二进制数据，读取到二进制数据不会经过任何的处理。</p>
<p>字符流： 字符流读取的数据是以字符为单位的 。 字符流也是读取文件中的二进制数据，不过会把这些二进制数据转换成我们能 识别的字符。  </p>
<p>字符流 = 字节流 + 解码</p>
</li>
<li><p>——| Writer 输出字符流的基类。 抽象类<br>———–| FileWriter 向文件数据数据的输出字符流</p>
<p>FileWriter的使用步骤：</p>
<pre><code>1. 找到目标文件。
2. 建立数据输出通道
3. 写出数据。
4. 关闭资源
</code></pre><p>FileWriter要注意的事项：</p>
<pre><code>1. 使用FileWriter写数据的时候，FileWriter内部是维护了一个1024个字符数组的，写数据的时候会先写入到它内部维护的字符数组中，如果需要
把数据真正写到硬盘上，需要调用flush或者是close方法或者是填满了内部的字符数组。
2. 使用FileWriter的时候，如果目标文件不存在，那么会自动创建目标文件。
3.使用FileWriter的时候， 如果目标文件已经存在了，那么默认情况会先情况文件中的数据，然后再写入数据 ， 如果需要在原来的基础上追加数据，
需要使用“new FileWriter(File , boolean)”的构造方法，第二参数为true。
</code></pre></li>
</ol>
<p>总结： 字节流</p>
<p>输入字节流：<br>———–| InputStream  所有输入字节流的基类  抽象类<br>—————–| FileInputStream 读取文件数据的输入字节流<br>—————–| BufferedInputStream  缓冲输入字符流       该类出现的目的是为了提高读取文件 数据的效率。 这个类其实只不过是在内部维护了一个8kb的字节数组而已。</p>
<p>输出字节流：<br>———–| OutputStream 所有输出字节流的基类。  抽象类。<br>—————-| FileOutputStream 向文件输出数据的输出字节流<br>—————-| BufferedOutputStream 缓冲输出字节流   该类出现的目的也是为了提高向文件写数据的效率。 这个类的也只不过是在内部维护了一个8kb的字节数组而已。</p>
<p>字符流 :  字符流 = 字节流  + 编码（解码）</p>
<p>输入字符流:<br>———| Reader   所有输入字符流的基类。  抽象类。<br>—————-| FileReader 读取文件数据的输入字符流。<br>—————-| BufferedReader 缓冲输入字符流           该类出现的目的是为了提高读取文件数据的效率与拓展FileReader的(readLine)功能。  这个类的也只不过是在内部维护了一个8kb的字符数组而已。</p>
<p>输出字符流:<br>———| Writer 所有输出字符流的基类。  抽象类<br>—————-| FileWriter 向文件输出数据的输出字符流<br>—————-| BufferedWriter 缓冲输出字符流        该类出现的目的是为了提高写文件数据的效率与拓展FileWriter的(newLine)功能.</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/06/13/Java底层基础容易遗忘知识点总结/">Java底层基础容易遗忘知识点总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Virya-Hh</a></p>
        <p><span>发布时间:</span>2018-06-13, 15:18:40</p>
        <p><span>最后更新:</span>2018-07-16, 11:08:52</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/06/13/Java底层基础容易遗忘知识点总结/" title="Java底层基础容易遗忘知识点总结">http://yoursite.com/2018/06/13/Java底层基础容易遗忘知识点总结/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/06/13/Java底层基础容易遗忘知识点总结/　　作者: Virya-Hh" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/07/02/VS2013-配置OpenCV时，出现的问题/">
                    VS2013 配置OpenCV时，出现的问题
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/05/31/立体匹配算法总结及研究进展/">
                    立体匹配算法总结及研究进展
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Java底层基础容易遗忘知识点总结　| Hexo　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://yoursite.com/2018/06/13/Java底层基础容易遗忘知识点总结/';
            this.page.identifier = '2018/06/13/Java底层基础容易遗忘知识点总结/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/07/02/VS2013-配置OpenCV时，出现的问题/" title="上一篇: VS2013 配置OpenCV时，出现的问题">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/05/31/立体匹配算法总结及研究进展/" title="下一篇: 立体匹配算法总结及研究进展">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/字符串最后一个单词的长度/">字符串最后一个单词的长度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/VS2013-配置OpenCV时，出现的问题/">VS2013 配置OpenCV时，出现的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/Java底层基础容易遗忘知识点总结/">Java底层基础容易遗忘知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/立体匹配算法总结及研究进展/">立体匹配算法总结及研究进展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/30/Java中对于字符串的认识/">Java中对于字符串的认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/30/关于数据库E-R图及关系模式的认识/">关于数据库E-R图及关系模式的认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/初探middlebury公开数据集/">初探middlebury公开数据集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/绑定域名出现的问题及解决/">绑定域名出现的问题及解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/24/软件测试了解及数据结构练习/">软件测试了解及数据结构练习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/hexo主题配置-yelee/">hexo主题配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/MATLAB之GUI界面搭建学习/">MATLAB之GUI界面搭建学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/github-hexo-个人博客搭建教程（一）（含填坑）/">github+hexo 个人博客搭建教程（一）（含填坑）</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 Virya-Hh
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 2;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>